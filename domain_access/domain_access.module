<?php

/**
 * @file
 * Domain-based access control for content.
 */

use Drupal\domain\DomainNegotiator;
use Drupal\domain\DomainInterface;
use Drupal\node\NodeInterface;
use Drupal\node\Entity\NodeType;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\Core\Field\FieldDefinitionInterface;
use Drupal\Core\Form\FormStateInterface;

/**
 * Defines the name of the node access control field.
 */
define('DOMAIN_ACCESS_NODE_FIELD', 'field_domain_access');

/**
 * Defines the names of the user assignment field.
 */
define('DOMAIN_ACCESS_USER_FIELD', 'field_domain_user');

/**
 * Defines the name of the all affiliates field.
 */
define('DOMAIN_ACCESS_ALL_FIELD', 'field_domain_all_affiliates');

/**
 * Implements hook_node_grants().
 */
function domain_access_node_grants(AccountInterface $account, $op) {
  $grants = array();
  $active = \Drupal::service('domain.negotiator')->getActiveDomain();

  if (empty($active)) {
    $active = \Drupal::service('domain.loader')->loadDefaultDomain();
  }

  // No domains means no permissions.
  if (empty($active)) {
    return $grants;
  }

  $id = $active->getDomainId();
  // Advanced grants for edit/delete require permissions.
  $user = \Drupal::entityManager()->getStorage('user')->load($account->id());
  $user_domains = domain_access_get_entity_values($user, DOMAIN_ACCESS_USER_FIELD);
  // Grants for view are simple. Use the active domain and all affiliates.
  // Note that "X to any domain" is a global permission designed for admins.
  if ($op == 'view') {
    $grants['domain_id'][] = $id;
    $grants['domain_site'][] = 0;
    if ($user->hasPermission('view unpublished domain content')) {
      if ($user->hasPermission('publish to any domain') || in_array($id, $user_domains) || !empty($user->get(DOMAIN_ACCESS_ALL_FIELD)->value)) {
        $grants['domain_unpublished'][] = $id;
      }
    }
  }
  elseif ($op == 'update' && $user->hasPermission('edit domain content')) {
    if ($user->hasPermission('publish to any domain') || in_array($id, $user_domains) || !empty($user->get(DOMAIN_ACCESS_ALL_FIELD)->value)) {
      $grants['domain_id'] = $id;
    }
  }
  elseif ($op == 'delete' && $user->hasPermission('delete domain content')) {
    if ($user->hasPermission('publish to any domain') || in_array($id, $user_domains) || !empty($user->get(DOMAIN_ACCESS_ALL_FIELD)->value)) {
      $grants['domain_id'] = $id;
    }
  }
  return $grants;
}

/**
 * Implements hook_node_access_records().
 */
function domain_access_node_access_records(NodeInterface $node) {
  $grants = array();
  // If there are no domains set, use the current one.
  $domains = domain_access_get_entity_values($node, DOMAIN_ACCESS_NODE_FIELD);
  if (empty($domains) && $active = \Drupal::service('domain.negotiator')->getActiveDomain()) {
    $domains[$active->id()] = $active->getDomainId();
  }
  foreach ($domains as $id => $domainId) {
    if ($domain = \Drupal::service('domain.loader')->load($id)) {
      $grants[] = array(
        'realm' => ($node->isPublished()) ? 'domain_id' : 'domain_unpublished',
        'gid' => $domain->getDomainId(),
        'grant_view' => 1,
        'grant_update' => 1,
        'grant_delete' => 1,
      );
    }
  }
  if (!empty($node->get(DOMAIN_ACCESS_ALL_FIELD)->value) && $node->isPublished()) {
    $grants[] = array(
      'realm' => 'domain_site',
      'gid' => 0,
      'grant_view' => 1,
      'grant_update' => 0,
      'grant_delete' => 0,
    );
  }
  return $grants;
}

/**
 * Sets the default value for new fields.
 */
function domain_access_default_value(FieldableEntityInterface $entity, FieldDefinitionInterface $definition) {
  $item = array();
  switch ($entity->getEntityType()) {
    case 'user':
    case 'node':
      if ($active = \Drupal::service('domain.negotiator')->getActiveDomain()) {
        $item[0]['target_uuid'] = $active->uuid();
      }
      break;
    default:
      break;
  }
  return $item;
}

/**
 * Sets the default value for the all affiliate fields.
 */
function domain_access_all_value(FieldableEntityInterface $entity, FieldDefinitionInterface $definition) {
  // @TODO: This may become configurable.
  $item = FALSE;
  switch ($entity->getEntityType()) {
    case 'user':
    case 'node':
      $item = FALSE;
      break;
    default:
      break;
  }
  return $item;
}

/**
 * Returns the Domain Access values from an entity.
 *
 * @param Drupal\Core\Entity\EntityInterface $entity
 *   The entity being checked.
 * @param $field_name
 *   The name of the field storing domain access values. Default fields are
 *   defined by this module.
 *
 * @return array
 *   An array of domain id values, where the key is id() and the value is domainId().
 */
function domain_access_get_entity_values($entity, $field_name) {
  // @TODO: static cache.
  $list = array();
  // @TODO In tests, $entity is returning NULL.
  if (is_null($entity)) {
    return $list;
  }
  // Get the values of an entity.
  $values = $entity->get($field_name);
  // Must be at least one item.
  if (!empty($values)) {
    foreach ($values as $item) {
      if ($target = $item->getValue()) {
        if ($domain = \Drupal::service('domain.loader')->load($target['target_id'])) {
          $list[$domain->id()] = $domain->getDomainId();
        }
      }
    }
  }
  return $list;
}

/**
 * Implements hook_node_presave().
 *
 * Fires only if Devel Generate module is present, to assign test nodes to
 * domains.
 *
 * @TODO: should we always set default values here?
 * @TODO: pull values from the Devel Generate form.
 *
 * @param \Drupal\Core\Entity\EntityInterface stdClass $node
 *   The node entity on which the operation is to be performed.
 */
function domain_access_node_presave(EntityInterface $node) {
  $exists = \Drupal::moduleHandler()->moduleExists('devel_generate');
  if ($exists && isset($node->devel_generate)) {
    // If set by the form.
    if (isset($node->devel_generate['domain_access'])) {
      $values = array(
        DOMAIN_ACCESS_NODE_FIELD => array_keys($node->devel_generate['domain_access']),
      );
    }
    // Else set randomly.
    else {
      $domains = \Drupal::service('domain.loader')->loadMultiple();
      $values = array(
        DOMAIN_ACCESS_NODE_FIELD => array_rand($domains, ceil(rand(1, count($domains)))),
      );
    }
    $node->setPropertyValues($values);
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function domain_access_form_devel_generate_content_form_alter(&$form, &$form_state, $form_id) {
  // Add our element to the devel generate form.
  $form['submit']['#weight'] = 10;
  $list = \Drupal::service('domain.loader')->loadOptionsList();
  $form['domain_access'] = array(
    '#title' => t('Domains'),
    '#type' => 'select',
    '#options' => $list,
    '#weight' => 2,
    '#multiple' => TRUE,
    '#size' => count($list) > 5 ? 5 : count($list),
    '#default_value' => array(\Drupal::service('domain.negotiator')->getActiveId()),
  );
}

/**
 * Implements hook_domain_source_alter().
 *
 * If this node is assigned to a domain other than current, rewrite the url
 * to point to the highest-weighted domain.
 *
 * This code is proof-of-concept and may be deprecated for Domain Source.
 */
function domain_access_domain_source_alter(&$source, $path, $options) {
  $node = $options['entity'];
  $list = domain_access_get_entity_values($node, DOMAIN_ACCESS_NODE_FIELD);
  // @TODO: setting to enable this rewrite, as in older versions?
  if ($list && $domains = \Drupal::service('domain.loader')->loadMultipleSorted($list)) {
    $first = current($domains);
    if ($first->id() != $options['active_domain']->id()) {
      $source = $first;
    }
  }
}

/**
 * Implements hook_domain_references_alter().
 */
function domain_access_domain_references_alter($query, $account, $entity_type) {
  // Restrict domains by assignment.
  switch ($entity_type) {
    case 'node':
      if ($account->hasPermission('publish to any domain')) {
        // Do nothing.
      }
      elseif ($account->hasPermission('publish to any assigned domain')) {
        $allowed = domain_access_get_entity_values($account, DOMAIN_ACCESS_USER_FIELD);
        $query->condition('id', array_keys($allowed), 'IN');
      }
      else {
        // Remove all options.
        $query->condition('id', '-no-possible-match-');
      }
      break;
    case 'user':
      if ($account->hasPermission('assign editors to any domain')) {
        // Do nothing.
      }
      elseif ($account->hasPermission('assign domain editors')) {
        $allowed = domain_access_get_entity_values($account, DOMAIN_ACCESS_USER_FIELD);
        $query->condition('id', array_keys($allowed), 'IN');
      }
      else {
        // Remove all options.
        $query->condition('id', '-no-possible-match-');
      }
      break;
    default:
      // No action taken.
      break;
  }
}

/**
 * Implements hook_node_access().
 */
function domain_access_node_access(NodeInterface $node, $op, AccountInterface $account) {
  // Check to see that we have a valid active domain.
  // Without one, we cannot assert an opinion about access.
  if ($active = \Drupal::service('domain.negotiator')->getActiveDomain()) {
    $id = $active->getDomainId();
  }
  else {
    return AccessResult::neutral();
  }

  $type = $node->bundle();

  switch ($op) {
    case 'update':
      if ($account->hasPermission('update ' . $type . ' content on assigned domains', $account) && domain_access_check_node($node, $account)) {
        return AccessResult::allowed()->cachePerPermissions()->cachePerUser()->cacheUntilEntityChanges($node);
      }
      if ($account->hasPermission('edit domain content', $account) && domain_access_check_node($node, $account)) {
        return AccessResult::allowed()->cachePerPermissions()->cachePerUser()->cacheUntilEntityChanges($node);
      }

    case 'delete':
      if ($account->hasPermission('delete ' . $type . ' content on assigned domains', $account) && domain_access_check_node($node, $account)) {
        return AccessResult::allowed()->cachePerPermissions()->cachePerUser()->cacheUntilEntityChanges($node);
      }
      if ($account->hasPermission('delete domain content', $account) && domain_access_check_node($node, $account)) {
        return AccessResult::allowed()->cachePerPermissions()->cachePerUser()->cacheUntilEntityChanges($node);
      }

    default:
      // No opinion.
      return AccessResult::neutral();
  }
}

/**
 * Checks that a node belongs to a domain that the user can edit.
 *
 * @param NodeInterface $node
 *   The node being checked.
 * @param AccountInterface $account
 *   The account making the access request.
 *
 * @return boolean
 */
function domain_access_check_node(NodeInterface $node, AccountInterface $account) {
  $node_domains = domain_access_get_entity_values($node, DOMAIN_ACCESS_NODE_FIELD);
  $user = \Drupal::entityManager()->getStorage('user')->load($account->id());
  if (!empty($user->get(DOMAIN_ACCESS_ALL_FIELD)->value) && !empty($node_domains)) {
    return TRUE;
  }
  $user_domains = domain_access_get_entity_values($account, DOMAIN_ACCESS_USER_FIELD);
  return (bool) !empty(array_intersect($node_domains, $user_domains));
}

/**
 * Implements hook_node_create_access().
 *
 * @link https://www.drupal.org/node/2348203
 */
function domain_access_node_create_access(AccountInterface $account, $context, $entity_bundle) {
  // Check to see that we have a valid active domain.
  // Without one, we cannot assert an opinion about access.
  if ($active = \Drupal::service('domain.negotiator')->getActiveDomain()) {
    $id = $active->getDomainId();
  }
  else {
    return AccessResult::neutral();
  }
  // Load the full user record.
  $user = \Drupal::entityManager()->getStorage('user')->load($account->id());
  $user_domains = domain_access_get_entity_values($user, DOMAIN_ACCESS_USER_FIELD);
  if (($account->hasPermission('create ' . $entity_bundle . ' content on assigned domains', $account)
      || $account->hasPermission('create domain content', $account))
      && in_array($id, $user_domains)) {
    // Note the cache context here!
    return AccessResult::allowed()->addCacheContexts(['user.permissions', 'url.site']);
  }
  // No opinion.
  return AccessResult::neutral();
}

/**
 * Implements hook_form_node_form_alter().
 *
 * Hides fields that the user cannot access.
 */
function domain_access_form_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Filtering of options happens in hook_domain_references_alter().
  if (isset($form[DOMAIN_ACCESS_NODE_FIELD])) {
    $form[DOMAIN_ACCESS_NODE_FIELD]['#access'] = !empty($form[DOMAIN_ACCESS_NODE_FIELD]['widget']['#options']);
  }
  if (isset($form[DOMAIN_ACCESS_ALL_FIELD])) {
    $account = \Drupal::currentUser();
    $form[DOMAIN_ACCESS_ALL_FIELD]['#access'] = $account->hasPermission('publish to any domain');
  }
}

/**
 * Implements hook_form_user_form_alter().
 *
 * Hides fields that the user cannot access.
 */
function domain_access_form_user_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Filtering of options happens in hook_domain_references_alter().
  if (isset($form[DOMAIN_ACCESS_USER_FIELD])) {
    $form[DOMAIN_ACCESS_USER_FIELD]['#access'] = !empty($form[DOMAIN_ACCESS_USER_FIELD]['widget']['#options']);
  }
}
